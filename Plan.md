# Покроковий план створення DataTable компонента

## Фаза 0: Підготовка (30-60 хв)

### Крок 0.1: Встановлення залежностей
```bash
npm install @tanstack/react-table
npm install @tanstack/react-virtual
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
npm install date-fns # для роботи з датами
npm install react-hook-form # для валідації форм
npm install zod # для схем валідації
```

### Крок 0.2: Створення структури файлів
```
src/components/DataTable/
├── index.tsx
├── types.ts
├── hooks/
├── components/
├── cells/
├── utils/
└── styles/ (якщо потрібно)
```

### Крок 0.3: Визначення базових типів (types.ts)
- Типи для колонок
- Типи для рядків
- Типи для фільтрів
- Типи для API responses
- Enum для типів клітинок

---

## Фаза 1: Базова таблиця (2-3 год)

### Крок 1.1: Створення базового компонента DataTable
**Мета:** Відобразити простий список даних у вигляді таблиці

**Що робимо:**
- Створюємо `index.tsx` з базовим компонентом
- Приймаємо props: `data`, `columns`, `tableId`
- Ініціалізуємо TanStack Table з `useReactTable`
- Рендеримо базову HTML таблицю (`<table>`, `<thead>`, `<tbody>`)

**Результат:** Статична таблиця, що показує дані

**Тестування:**
- Перевірити відображення 10-20 рядків
- Перевірити всі колонки

### Крок 1.2: Типізація колонок
**Мета:** Створити гнучку систему визначення колонок

**Що робимо:**
- Розширюємо `ColumnDef` з TanStack Table
- Додаємо власні властивості:
  - `cellType`: 'text' | 'number' | 'date' | 'dateRange' | 'select' | 'checkbox' | 'custom'
  - `editable`: boolean
  - `filterable`: boolean
  - `sortable`: boolean
  - `filterType`: тип фільтра для колонки
  - `validationSchema`: Zod schema

**Результат:** Типізована система колонок

### Крок 1.3: Базовий рендеринг клітинок
**Мета:** Створити фабрику для різних типів клітинок

**Що робимо:**
- Створюємо `cells/CellRenderer.tsx`
- Створюємо switch/map для різних типів
- Поки робимо тільки read-only версії:
  - `TextCell.tsx` - простий текст
  - `NumberCell.tsx` - форматоване число
  - `DateCell.tsx` - форматована дата
  - `CheckboxCell.tsx` - disabled checkbox

**Результат:** Таблиця з правильно відформатованими даними

**Тестування:**
- Створити тестові дані з усіма типами
- Перевірити форматування

---

## Фаза 2: Сортування (1-2 год)

### Крок 2.1: Клієнтське сортування
**Мета:** Додати можливість сортування колонок

**Що робимо:**
- Використовуємо вбудоване сортування TanStack Table
- Додаємо `getSortedRowModel` до table config
- Додаємо `onSortingChange` handler
- Створюємо `TableHeader.tsx` з іконками сортування (↑↓)
- Додаємо візуальні індикатори активного сортування

**Результат:** Клікабельні заголовки з сортуванням

**Тестування:**
- Відсортувати по кожній колонці
- Перевірити asc/desc/none стани
- Перевірити з різними типами даних

### Крок 2.2: Серверне сортування
**Мета:** Підготувати до роботи з API для великих датасетів

**Що робимо:**
- Створюємо `hooks/useTableState.ts`
- Додаємо `manualSorting` mode
- Створюємо функцію для генерації sort params для API
- Додаємо prop `onSortChange` для батьківського компонента

**Результат:** Можливість переключення між client/server sorting

**Тестування:**
- Замокати API response
- Перевірити параметри запиту

---

## Фаза 3: Фільтрування (3-4 год)

### Крок 3.1: Швидкий пошук (Global Search)
**Мета:** Додати пошук по всіх колонках

**Що робимо:**
- Створюємо `components/GlobalSearch.tsx`
- Додаємо input з debounce (300ms)
- Використовуємо `setGlobalFilter` з TanStack Table
- Додаємо кастомну функцію `globalFilterFn`

**Результат:** Пошукове поле над таблицею

**Тестування:**
- Шукати різні терміни
- Перевірити debounce
- Перевірити з кирилицею

### Крок 3.2: Фільтр попап компонент
**Мета:** Створити UI для фільтрування колонок

**Що робимо:**
- Створюємо `components/FilterPopover.tsx`
- Додаємо іконку фільтра в заголовок колонки
- Створюємо попап (можна використати headlessui або radix-ui)
- Додаємо базовий layout для фільтрів

**Результат:** Клікабельна іконка з попапом

### Крок 3.3: Типи фільтрів
**Мета:** Реалізувати різні типи фільтрів

**Що робимо:**
Створюємо окремі компоненти фільтрів:

**3.3.1 TextFilter:**
- Input для введення тексту
- Режими: contains, equals, startsWith, endsWith
- Checkbox "Case sensitive"

**3.3.2 NumberFilter:**
- Два інпути для діапазону (from/to)
- Режими: equals, between, greaterThan, lessThan

**3.3.3 DateFilter:**
- Date picker для одиночної дати
- Режими: equals, before, after

**3.3.4 DateRangeFilter:**
- Два date pickers (start/end)

**3.3.5 SelectFilter:**
- Multi-select чекбокси
- "Select All" / "Clear All"
- Пошук по опціях (якщо багато)

**Результат:** Повний набір фільтрів для всіх типів даних

**Тестування:**
- Кожен тип фільтра окремо
- Комбінація фільтрів

### Крок 3.4: Логіка фільтрування
**Мета:** З'єднати UI з логікою фільтрування

**Що робимо:**
- Створюємо `hooks/useTableFilters.ts`
- Зберігаємо активні фільтри в стані
- Реалізуємо AND логіку між колонками
- Реалізуємо OR логіку всередині колонки (для multi-select)
- Додаємо `getFilteredRowModel` до table config

**Результат:** Працююча система фільтрів

**Тестування:**
- Фільтрувати по одній колонці
- Комбінувати фільтри по різних колонках
- Перевірити AND/OR логіку

### Крок 3.5: Індикатори активних фільтрів
**Мета:** Показати користувачу активні фільтри

**Що робимо:**
- Додаємо бейдж на іконці фільтра (кількість)
- Створюємо "chips" над таблицею з активними фільтрами
- Додаємо кнопку "Clear all filters"

**Результат:** Зрозуміло, які фільтри активні

---

## Фаза 4: Інлайн редагування (4-5 год)

### Крок 4.1: Режим редагування клітинки
**Мета:** Зробити клітинки редагованими

**Що робимо:**
- Створюємо `components/EditableCell.tsx`
- Додаємо стан `isEditing` для кожної клітинки
- По кліку перемикаємо в режим редагування
- Показуємо відповідний input замість тексту
- По blur або Enter зберігаємо
- По Escape скасовуємо

**Результат:** Клітинка стає інпутом по кліку

**Тестування:**
- Клік для редагування
- Enter для збереження
- Escape для скасування
- Tab для переходу до наступної клітинки

### Крок 4.2: Редаговані версії всіх типів клітинок
**Мета:** Створити edit mode для кожного типу

**Що робимо:**

**4.2.1 EditableTextCell:**
- Звичайний input type="text"
- Валідація maxLength, pattern

**4.2.2 EditableNumberCell:**
- Input type="number"
- Валідація min, max, step
- Форматування при виході з режиму

**4.2.3 EditableDateCell:**
- Date picker (можна використати react-datepicker)
- Валідація min/max date

**4.2.4 EditableDateRangeCell:**
- Два date pickers
- Валідація що end >= start

**4.2.5 EditableSelectCell:**
- Dropdown або autocomplete
- Single select

**4.2.6 EditableCheckboxCell:**
- Вже інтерактивний, просто toggle

**Результат:** Всі типи клітинок редаговані

### Крок 4.3: Валідація на рівні клітинки
**Мета:** Перевіряти дані перед збереженням

**Що робимо:**
- Інтегруємо Zod schemas з колонок
- Показуємо помилки валідації під/біля клітинки
- Блокуємо збереження при помилках
- Додаємо візуальні індикатори (червона рамка)

**Результат:** Валідація в реальному часі

**Тестування:**
- Ввести невалідні дані
- Перевірити повідомлення про помилки
- Спробувати зберегти невалідні дані

### Крок 4.4: Валідація на рівні рядка
**Мета:** Перевіряти залежності між полями

**Що робимо:**
- Створюємо `rowValidationSchema` prop
- Запускаємо валідацію при зміні будь-якого поля
- Показуємо помилки рядка в окремій секції
- Підсвічуємо весь рядок при помилці

**Результат:** Крос-поле валідація

**Тестування:**
- Створити залежні поля (напр. start_date < end_date)
- Перевірити валідацію

### Крок 4.5: Unsaved changes tracking
**Мета:** Відстежувати незбережені зміни

**Що робимо:**
- Створюємо `hooks/useUnsavedChanges.ts`
- Зберігаємо оригінальні значення
- Порівнюємо з поточними
- Додаємо візуальний індикатор (крапка, зірочка)
- Показуємо кнопки Save/Cancel для рядка

**Результат:** Видно які рядки змінені

### Крок 4.6: Збереження змін
**Мета:** Відправляти зміни на сервер

**Що робимо:**
- Створюємо `onRowUpdate` callback prop
- Додаємо optimistic updates
- Реалізуємо rollback при помилці
- Показуємо loading state
- Показуємо success/error notifications

**Результат:** Працююче збереження

**Тестування:**
- Редагувати і зберегти
- Імітувати помилку сервера
- Перевірити rollback

---

## Фаза 5: Створення нових рядків (2-3 год)

### Крок 5.1: Додавання порожнього рядка
**Мета:** Можливість створити новий рядок

**Що робимо:**
- Додаємо кнопку "Add Row" над/під таблицею
- Створюємо новий рядок зі значеннями по замовчуванню
- Додаємо рядок в стан таблиці
- Автоматично переводимо в режим редагування
- Візуально виділяємо новий рядок

**Результат:** Можна додати новий рядок

**Тестування:**
- Додати рядок
- Перевірити значення за замовчуванням
- Перевірити автофокус на першому полі

### Крок 5.2: Копіювання рядка
**Мета:** Швидко створити рядок на основі існуючого

**Що робимо:**
- Додаємо іконку/кнопку "Copy" для кожного рядка
- Клонуємо дані рядка
- Вставляємо копію на позицію нижче
- Генеруємо новий temporary ID
- Позначаємо як новий (unsaved)

**Результат:** Можна копіювати рядки

**Тестування:**
- Скопіювати різні рядки
- Перевірити позицію вставки
- Перевірити що ID новий

### Крок 5.3: Збереження нових рядків
**Мета:** Відправити нові рядки на сервер

**Що робимо:**
- Створюємо `onRowCreate` callback prop
- Валідуємо обов'язкові поля
- Відправляємо на сервер
- Замінюємо temporary ID на server ID
- Обробляємо помилки

**Результат:** Нові рядки зберігаються

**Тестування:**
- Створити і зберегти новий рядок
- Спробувати зберегти без обов'язкових полів
- Перевірити що ID оновився

### Крок 5.4: Видалення рядків
**Мета:** Можливість видалити рядок

**Що робимо:**
- Додаємо кнопку/іконку "Delete"
- Показуємо confirmation dialog
- Для нових (незбережених) - видаляємо зі стану
- Для існуючих - викликаємо `onRowDelete`
- Додаємо optimistic update

**Результат:** Можна видаляти рядки

---

## Фаза 6: Drag & Drop переміщення рядків (3-4 год)

### Крок 6.1: Налаштування DndKit
**Мета:** Підготувати інфраструктуру для drag & drop

**Що робимо:**
- Обгортаємо таблицю в `DndContext`
- Налаштовуємо sensors (pointer, keyboard)
- Створюємо collision detection strategy
- Додаємо accessibility announcements

**Результат:** DndKit готовий до використання

### Крок 6.2: Draggable rows
**Мета:** Зробити рядки перетягуваними

**Що робимо:**
- Створюємо `hooks/useRowDragDrop.ts`
- Обгортаємо кожен рядок в `useSortable`
- Додаємо drag handle (іконка ≡) на початку рядка
- Додаємо візуальний feedback при перетягуванні
- Рядок стає напівпрозорим під час drag

**Результат:** Рядки можна перетягувати

**Тестування:**
- Спробувати перетягнути рядок
- Перевірити drag handle

### Крок 6.3: Drop zones і візуальні індикатори
**Мета:** Показати куди можна drop

**Що робимо:**
- Додаємо горизонтальні лінії між рядками (drop indicators)
- Підсвічуємо target drop zone
- Показуємо preview позиції
- Додаємо smooth animations

**Результат:** Зрозуміло куди буде вставлений рядок

### Крок 6.4: Логіка переміщення
**Мета:** Реалізувати фактичне переміщення

**Що робимо:**
- В `onDragEnd` handler:
  - Визначаємо нову позицію
  - Оновлюємо масив рядків
  - Зберігаємо новий order на сервері
- Додаємо `onRowReorder` callback prop
- Реалізуємо optimistic update

**Результат:** Рядки переміщаються

**Тестування:**
- Перемістити рядок вгору
- Перемістити рядок вниз
- Перемістити на першу позицію
- Перемістити на останню позицію

### Крок 6.5: Drag & Drop з фільтрами/сортуванням
**Мета:** Коректна робота при активних фільтрах

**Що робимо:**
- Працюємо з filtered/sorted індексами
- Перераховуємо позиції після drop
- Показуємо попередження якщо є активні фільтри
- Опціонально: вимикаємо drag при сортуванні

**Результат:** D&D працює коректно з іншими фічами

---

## Фаза 7: Віртуалізація для великих таблиць (2-3 год)

### Крок 7.1: Інтеграція TanStack Virtual
**Мета:** Оптимізувати рендеринг великих списків

**Що робимо:**
- Додаємо `useVirtualizer` з @tanstack/react-virtual
- Створюємо `components/VirtualizedTableBody.tsx`
- Рендеримо тільки видимі рядки
- Додаємо padding для підтримки scroll
- Налаштовуємо `overscan` для smooth scrolling

**Результат:** Швидка робота з тисячами рядків

**Тестування:**
- Завантажити 5000 рядків
- Перевірити scroll performance
- Перевірити що все працює (фільтри, сортування, редагування)

### Крок 7.2: Динамічна висота рядків
**Мета:** Підтримка рядків різної висоти

**Що робимо:**
- Використовуємо `dynamic` sizing mode
- Вимірюємо реальну висоту рядків
- Оновлюємо virtualizer при зміні контенту

**Результат:** Коректний scroll з різними висотами

### Крок 7.3: Оптимізація ре-рендерів
**Мета:** Мінімізувати непотрібні рендери

**Що робимо:**
- Мемоїзуємо компоненти з `React.memo`
- Використовуємо `useMemo` для обчислень
- Оптимізуємо column definitions
- Додаємо `React.useCallback` для handlers

**Результат:** Плавна робота UI

---

## Фаза 8: Серверна інтеграція (3-4 год)

### Крок 8.1: API клієнт
**Мета:** Створити слой для роботи з API

**Що робимо:**
- Створюємо `utils/api.ts`
- Додаємо функції:
  - `fetchTableData(tableId, params)`
  - `updateRow(tableId, rowId, data)`
  - `createRow(tableId, data)`
  - `deleteRow(tableId, rowId)`
  - `reorderRows(tableId, order)`
  - `saveTableState(tableId, userId, state)`
  - `loadTableState(tableId, userId)`

**Результат:** Централізована робота з API

### Крок 8.2: Server-side фільтрування/сортування
**Мета:** Відправляти операції на сервер

**Що робимо:**
- Створюємо функцію для серіалізації фільтрів в query params
- Додаємо `manualFiltering` і `manualSorting` modes
- При зміні фільтрів/сортування - запит на сервер
- Додаємо loading states
- Реалізуємо pagination

**Результат:** Робота з великими датасетами на сервері

### Крок 8.3: Збереження стану таблиці
**Мета:** Зберігати preferences користувача

**Що робимо:**
- Зберігаємо на сервері:
  - Активні фільтри
  - Порядок сортування
  - Ширину колонок (опціонально)
  - Видимість колонок (опціонально)
- Завантажуємо при mount
- Дебоунс збереження (3-5 сек після зміни)

**Результат:** Персональні налаштування зберігаються

### Крок 8.4: Optimistic updates і conflict resolution
**Мета:** Швидкий UI + надійність

**Що робимо:**
- Оновлюємо UI одразу
- Відправляємо запит в фоні
- При помилці - rollback
- Додаємо version/timestamp для виявлення конфліктів
- При конфлікті - показуємо dialog "refresh data?"

**Результат:** Responsive UI з обробкою помилок

---

## Фаза 9: Мобільна адаптація (4-5 год)

### Крок 9.1: Breakpoints і responsive layout
**Мета:** Визначити точки переходу

**Що робимо:**
- Створюємо `hooks/useBreakpoint.ts`
- Визначаємо breakpoints: mobile (<768px), tablet (768-1024px), desktop (>1024px)
- Додаємо медіа-запити

**Результат:** Система для адаптивності

### Крок 9.2: Мобільний вигляд - картки
**Мета:** Замість таблиці показувати картки

**Що робимо:**
- Створюємо `components/MobileCard.tsx`
- Показуємо key fields вгорі картки
- Інші поля - в collapse секції
- Додаємо expand/collapse функціонал
- Зберігаємо всі дії (edit, delete, drag)

**Результат:** Зручний мобільний вигляд

### Крок 9.3: Мобільні фільтри
**Мета:** Адаптувати фільтри під маленький екран

**Що робимо:**
- Замість поповерів - повноекранний modal/drawer
- Вертикальний layout фільтрів
- Великі touch targets (мін 44px)
- Кнопки Apply/Reset внизу екрану

**Результат:** Зручні фільтри на мобайлі

### Крок 9.4: Touch gestures
**Мета:** Додати свайпи та інші жести

**Що робимо:**
- Swipe right на картці - delete (з confirmation)
- Swipe left - copy
- Long press - drag mode
- Pull to refresh (опціонально)

**Результат:** Native-like experience

### Крок 9.5: Мобільне редагування
**Мета:** Зручне редагування на touch пристроях

**Що робимо:**
- Повноекранний edit mode для рядка
- Великі інпути з правильними keyboard types
- Автофокус і автоскрол до активного поля
- Save/Cancel buttons завжди видимі (sticky)

**Результат:** Зручне редагування на мобайлі

---

## Фаза 10: Додаткові фічі та polish (3-4 год)

### Крок 10.1: Масові операції (Bulk actions)
**Мета:** Робота з багатьма рядками одночасно

**Що робимо:**
- Додаємо checkbox для вибору рядків
- "Select All" checkbox в хедері
- Toolbar з bulk actions (delete, export, etc.)
- Показуємо кількість вибраних рядків

**Результат:** Можна працювати з багатьма рядками

### Крок 10.2: Export/Import
**Мета:** Вивантаження та завантаження даних

**Що робимо:**
- Export в CSV/Excel
- Враховуємо активні фільтри
- Import з валідацією
- Показуємо preview перед імпортом
- Error handling для невалідних даних

**Результат:** Інтеграція з Excel

### Крок 10.3: Column visibility toggle
**Мета:** Приховувати непотрібні колонки

**Що робимо:**
- Створюємо dropdown меню з чекбоксами колонок
- Зберігаємо в стані користувача
- Мінімум одна колонка завжди видима

**Результат:** Кастомізація вигляду таблиці

### Крок 10.4: Resize колонок
**Мета:** Змінювати ширину колонок

**Що робимо:**
- Додаємо resize handles між колонками
- Drag для зміни ширини
- Double-click для auto-fit
- Зберігаємо ширини

**Результат:** Гнучкий layout

### Крок 10.5: Keyboard navigation
**Мета:** Повна підтримка клавіатури

**Що робимо:**
- Arrow keys для навігації між клітинками
- Enter для редагування
- Tab для переходу до наступної клітинки
- Ctrl+C/V для copy/paste
- Escape для виходу з режиму редагування

**Результат:** Power user features

### Крок 10.6: Loading states і skeleton screens
**Мета:** Плавні переходи при завантаженні

**Що робимо:**
- Skeleton loader для initial load
- Spinner для filtering/sorting
- Progress bar для bulk operations
- Smooth transitions

**Результат:** Приємний UX

### Крок 10.7: Empty states
**Мета:** Інформативні порожні стани

**Що робимо:**
- Порожня таблиця - onboarding message
- Немає результатів фільтрування - "No results" з кнопкою clear
- Помилка завантаження - retry button
- Додаємо ілюстрації

**Результат:** Зрозумілі порожні стани

---

## Фаза 11: Тестування та документація (2-3 год)

### Крок 11.1: Unit тести
**Що тестуємо:**
- Hooks (useTableState, useTableFilters)
- Utility functions
- Cell components
- Validation logic

### Крок 11.2: Integration тести
**Що тестуємо:**
- CRUD операції
- Фільтрування + сортування
- Drag & Drop
- Мобільний вигляд

### Крок 11.3: E2E тести
**Що тестуємо:**
- Повні user flows
- Крос-браузерна сумісність
- Performance на різних обсягах даних

### Крок 11.4: Документація
**Що створюємо:**
- README з прикладами використання
- API reference для props
- Storybook (опціонально)
- Migration guide (якщо заміняє існуючу таблицю)

---

## Загальна оцінка часу:

- **Фаза 0:** 0.5-1 год
- **Фаза 1:** 2-3 год
- **Фаза 2:** 1-2 год
- **Фаза 3:** 3-4 год
- **Фаза 4:** 4-5 год
- **Фаза 5:** 2-3 год
- **Фаза 6:** 3-4 год
- **Фаза 7:** 2-3 год
- **Фаза 8:** 3-4 год
- **Фаза 9:** 4-5 год
- **Фаза 10:** 3-4 год
- **Фаза 11:** 2-3 год

**Загалом: 30-42 години чистого розробницького часу**

---

## Рекомендації по порядку розробки:

**Якщо потрібен швидкий MVP:**
1. Фази 1, 2, 3.1-3.3 (базова таблиця з пошуком і простими фільтрами)
2. Фаза 4.1-4.2 (базове редагування)
3. Фаза 8.1-8.2 (базова інтеграція з API)

**Повний функціонал по пріоритету:**
1. Фази 1-3 (відображення і фільтрування)
2. Фаза 4 (редагування)
3. Фаза 8 (серверна інтеграція)
4. Фаза 5 (створення рядків)
5. Фаза 6 (drag & drop)
6. Фаза 9 (мобільна версія)
7. Фази 7, 10 (оптимізація та додаткові фічі)


